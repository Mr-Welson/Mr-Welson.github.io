<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TypeScript]]></title>
    <url>%2F2019%2F04%2F01%2Ftypescript%2F</url>
    <content type="text"><![CDATA[简介TypeScript 是 JavaScript 的一个超集，主要提供了 类型系统 和对 ES6 的支持，由 Microsoft 开发。 应用：vue3.0，angular2.0，vscode… 编译型语言：编译为 js 后运行，单独无法运行; 强类型语言; 面向对象的语言; 优势 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用； 可以在编译阶段就发现大部分错误，这总比在运行时候出错好； 增强了编辑器和 IDE 的功能，包括代码补全、接口提示、跳转到定义、重构等； 总结：TypeSctipt增加了代码的可读性和可维护性。 安装需要有node环境，通过npm安装 npm install -g typescript 编码在线编译预览 TS 使用 .ts 文件扩展名， 使用 typescript 编写使用 React 时，使用 .tsx 扩展名。 使用 : 指定变量的类型，: 的前后有没有空格都可以; function sayHello(person: string) &#123; return &apos;Hello, &apos; + person;&#125;let user = &apos;Tom&apos;;console.log(sayHello(user)); 编译使用tsc 命令可编译 .ts 文件， 生成一个同名 .js 文件；编译的时候即使报错了，还是会生成编译结果(.js)，可通过 tsconfig.json 文件配置 tsc demo.ts 基础类型布尔值 booleanlet isDone: boolean = false; 注意，使用构造函数 Boolean 创造的对象不是布尔值 let newBool: boolean = new Boolean(true);// 编译报错: 不能将类型“Boolean”分配给类型“boolean”。“boolean”是基元，但“Boolean”是包装器对象。如可能首选使用“boolean”。ts(2322) 数字 numberlet number: number = 6;let notANumber: number = NaN; 字符串 stringlet string: string = 'Tom';let sentence: string = `my name is $&#123;aString&#125;`; 空值 voidvoid 类型的变量只能赋值为 undefined 和 null let unusable: void = undefined; 可以用 void 表示没有任何返回值的函数 function alertName(): void &#123; alert(&apos;My name is Tom&apos;);&#125; null 和 undefinedundefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null let u: undefined = undefined;let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： let u: undefined;let num: number = u;let num2:number = undefined;// 编译合法 undefined是number的子类型let unm2: void;let num3: number = unm2;// =&gt; 不合法 (void不是number的子类型) 任意值 anyany 用来表示允许赋值为任意类型 let anyType:any = &apos;seven&apos;;anyType = 7; 在任意值上访问任何属性和方法都是允许的，即不做类型检查 let anyType:any = &apos;seven&apos;;console.log(anyType.name().age) // =&gt; 允许编译，但是js执行会报错 变量如果在声明的时候，未指定其类型， 也没有赋值， 那么它会被推断(类型推论)为任意值类型而完全不被类型检查 let something; // 等价于 let something: any;something = &apos;seven&apos;;something = 7; 数组可理解为相同类型的一组数据，数组类型有多种定义方式 1，类型 + 方括号（ type [ ] ） 这种方式定义的数组项中不允许出现其他的类型 let list: number[] = [1, 2, 3]; 2，数组泛型 Array &lt; type &gt; let list: Array&lt;number&gt; = [1, 2, 3]; 元祖 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同，简单理解为可定义一组不同类型的数据： let arr:[string, number] = [&apos;name&apos;, 20];console.log(arr[0]); // =&gt; &apos;name&apos; 越界元素：当访问超出元祖长度的元素时，它的类型会被限制为元祖中每个类型的联合类型 let arr:[string, number] = [&apos;name&apos;, 20];arr[0] = &apos;age&apos;;arr[2] = &apos;string&apos;;arr[3] = 40;arr[4] = true; // 编译报错 枚举 enum[‘enəm] 枚举类型用于取值被限定在一定范围内的场景，如一周只有7天，一年只有4季等。 枚举初始化枚举初始化可以理解为给枚举成员赋值。每个枚举成员都需要带有一个值，在未赋值的情况下， 枚举成员会被赋值为从 0 开始， 步长为 1 递增的数字： enum Weeks &#123;Mon, Tue, Wed, Thu, Fri, Sat, Sun&#125;;console.log(Weeks[&apos;Mon&apos;]); // =&gt; 0console.log(Weeks[0]); // =&gt; &apos;Mon&apos;console.log(Weeks.Tue); // =&gt; 1 手动赋值时， 未赋值的枚举成员会接着上一个枚举项递增（初始化）： enum Weeks &#123; Mon, Tue, Wed, Thu = 2, Fri, Sat = -1.5, Sun&#125;;console.log(Weeks['Mon']); // =&gt; 0console.log(Weeks.Wed); // =&gt; 2console.log(Weeks.Thu); // =&gt; 2console.log(Weeks.Fri); // =&gt; 3console.log(Weeks.Sun); // =&gt; -0.5 上例中，未手动赋值的 Wed 和手动赋值的 Thu 取值重复了，但是 TypeScript 并不会报错，该种情况可能会引起取值错误，所以使用的时候最好避免出现取值重复的情况。 TypeScript 支持 数字 的和基于字符串的枚举。 数字枚举enum Weeks &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;; 字符串枚举enum Direction &#123; Up = &quot;UP&quot;, Down = &quot;DOWN&quot;, Left = &quot;LEFT&quot;, Right = &quot;RIGHT&quot;,&#125; 异构枚举（Heterogeneous enums）可以混合字符串和数字，但通常不这么做 enum Gender &#123; Male = 0, Female = &quot;1&quot;,&#125; 常量成员和计算所得成员枚举成员的值可以是 常量 或 计算出来的。 上面所举的例子都是常量成员，官网定义如下： 当满足以下条件时，枚举成员被当作是常数： 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： 数字字面量 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~ 一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错 所有其它情况的枚举成员被当作是需要计算得出的值。 常量枚举 const enum常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。 const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译后： var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举 declare enum外部枚举与声明语句一样，常出现在声明文件中。 declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译后： var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 同时使用 declare 和 const 也是可以的，编译结果同常量枚举一致。 never永远不存在值的类型，一般用于错误处理函数。 // 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125; symbol自ECMAScript 2015起，symbol成为了一种新的原生类型，就像 number 和 string 一样。 symbol类型的值是通过Symbol构造函数创建的。 let sym1 = Symbol(); Symbols是不可改变且唯一的。 let sym2 = Symbol(&quot;key&quot;);let sym3 = Symbol(&quot;key&quot;);sym2 === sym3; // false, symbols是唯一的 更多用法参看 阮一峰ES6的symbol objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 function create(o: object | null): void;create(&#123; prop: 0 &#125;); // OKcreate(null); // OKcreate(42); // Errorcreate(&quot;string&quot;); // Errorcreate(false); // Errorcreate(undefined); // Error 内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 ECMAScript 的内置对象Boolean、Error、Date、RegExp 等。更多的内置对象，可以查看 MDN 的文档。 let b: Boolean = new Boolean(1);let e: Error = new Error(&apos;Error occurred&apos;);let d: Date = new Date();let r: RegExp = /[a-z]/; DOM 和 BOM 的内置对象Document、HTMLElement、Event、NodeList 等。 let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&apos;div&apos;);document.addEventListener(&apos;click&apos;, function(e: MouseEvent) &#123; // Do something&#125;); 类型推论变量申明如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型 let string = &apos;seven&apos;;// 等价于 let string: string = &apos;seven&apos;;string = 4;// 编译报错: error TS2322: Type &apos;number&apos; is not assignable to type &apos;string&apos; 变量声明但是未赋值，会推论为 any let x;x = 1;x = &apos;aaa&apos; 联合类型表示取值可以为多种类型中的一种，使用 | 分隔每个类型 let stringOrNumber:string | number;stringOrNumber = &apos;seven&apos;; 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候, 我们只能访问此联合类型的所有类型里共有的属性或方法 function getString(something: string | number): string &#123; // toString 是 string类型 和 number类型 的共有属性 return something.toString();&#125;function getLength(something: string | number): number &#123; return something.length; // =&gt; 编译报错: length 不是 string类型 和 number类型 的共有属性, 所以报错&#125; 类型断言类型断言（Type Assertion）可以用来手动指定一个值的类型。 类型断言有2种形式： 1，&lt;类型&gt;值 ( 尖括号语法 ) let someValue: any = &quot;this is a string&quot;;let strLength: number = (&lt;string&gt;someValue).length; 2，值 as 类型 ( as 语法 ) 当使用 tsx 时，只有 as语法断言是被允许的 let someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; 在上述 联合类型 的例子中， getLength 方法会编译报错，此时我们可以使用类型断言，将 something 断言成 string 就不会报错了： function getLength(something: string | number): number &#123; if ((&lt;string&gt;something).length) &#123; // 将 something 断言为 string类型 return (&lt;string&gt;something).length; &#125; else &#123; return something.toString().length; &#125;&#125; 注意 : 类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的： function toBoolean(something: string | number): boolean &#123; return &lt;boolean&gt;something; // =&gt; 报错&#125; 类型别名 type类型别名用来给一个类型起个新名字，多用于联合类型： type Name = string;type GetName = () =&gt; string;type NameOrGetter = Name | GetName;function getName(n: NameOrGetter): Name &#123; if (typeof n === &apos;string&apos;) &#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个。 type EventNames = &apos;click&apos; | &apos;scroll&apos; | &apos;mousemove&apos;;function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById(&apos;hello&apos;), &apos;scroll&apos;); // 没问题handleEvent(document.getElementById(&apos;world&apos;), &apos;dbclick&apos;); // 报错，event 不能为 &apos;dbclick&apos; 接口 Interfaces接口（Interfaces）是一个很重要的概念，可以理解为一种规范或者约束，用来描述 对象(object) 的形状 或者对 类(class) 的行为 进行抽象。对类的行为抽象将在后面 类与接口 一章中介绍，下面主要介绍对对象的形状进行描述。 接口定义使用 interface 定义接口, 接口名称一般首字母大写，定义接口的时候，只定义声明即可，不包含具体内容： // 定义一个接口 Personinterface Person &#123; name: string; age: number;&#125;// 定义一个个变量，它的类型是 Personlet tom: Person = &#123; name: &apos;Tom&apos;, age: 25&#125;; 实现接口的时候，要实现里面的内容，定义的变量比接口少了或多了属性都是不允许的： let tom: Person = &#123; name: &apos;tom&apos;&#125;// =&gt; 编译报错，少了age属性 可选属性使用 ? 代表可选属性, 即该属性可以不存在, 但不允许添加未定义的属性 interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: &apos;tom&apos;&#125;// age是可选属性 任意属性定义了任意属性后可以添加未定义的属性，并可以指定属性值的类型 interface Person03 &#123; name: string; age?: number; [propName: string]: any;&#125;let tom04: Person03 = &#123; name: &apos;Tom&apos;, age: 25, gender: &apos;male&apos;&#125;; 定义了任意属性，那么确定属性和可选属性都必须是它的子属性 interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;// 编译报错：Person定义了一个任意属性，其值为string类型。则Person的所有属性都必须为string类型，而age为number类型 只读属性 readonlyinterface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125; 只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 let person: Person = &#123; id: 100, name: 'tom',&#125;person05.id = 90;// =&gt; 编译报错：id为只读, 不可修改let person2: Person = &#123; name: 'welson', age: 2&#125;// =&gt; 编译报错：给对象 person2 赋值，未定义只读属性idperson2.id = 1;// =&gt; 编译报错：id为只读, 不可修改 函数类型接口// 只有参数列表和返回值类型的函数定义, 参数列表里的每个参数都需要名字和类型interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 函数函数声明function sum(x: number, y: number): number &#123; return x + y;&#125; 输入多余的（或者少于要求的）参数，是不被允许的 sum(1, 2, 3);// 编译报错：多了1个参数 匿名函数（函数表达式）let mySum = function (x: number, y: number): number &#123; return x + y;&#125;; 上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样： let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125;;// 注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt; 用接口定义函数的形状interface FuncAdd &#123; (value: number, increment: number): number&#125;let add: FuncAdd;add = function(value: number, increment: number): number &#123; return value + increment;&#125;// 函数的参数名不需要与接口里定义的名字相匹配let add2: FuncAdd;add2 = function(a: number, b: number) &#123; return a + b;&#125; 可选参数可选参数必须接在必需参数后面，换句话说，可选参数后面不允许再出现必须参数了 function addNum(a: number, b: number, c? :number): number &#123; if(c) &#123; return a + b + c; &#125; else &#123; return a + b; &#125;&#125;console.log(add(1, 2)); 默认参数类比 ES6 中的默认值 function add(a: number = 1, b: number): number &#123; return a + b;&#125;console.log(add(undefined, 1)); 剩余参数类比 Es6 中对象展开 interface AddFunc &#123; (num1: number, ...rest: number[]): number&#125;let add: AddFunc;add = function(a: number, ...rest: number[]): number &#123; let result = a; rest.map(v =&gt; result += v); return result;&#125;console.log(add(1,2,3,4)); 函数重载重载是为同一个函数提供多个函数类型定义，允许函数对传入不同的参数返回不同的的结果分别做类型检查 比如实现一个数字或字符串的反转函数： function reverse(text: number | string): number | string &#123; if(typeof text === 'string') &#123; return text.split('').reverse().join(''); &#125; else if(typeof text === 'number') &#123; return +text.toString().split('').reverse().join('') &#125;&#125; 上述函数利用联合类型实现，但有一个缺点，无法精确检查输入和输出类型，即输入数字输出也应该为数字，这时就可以使用重载定义多个函数类型: function reverse(text: number): number;function reverse(text: string): string;function reverse(text: number | string): number | string &#123; if(typeof text === &apos;string&apos;) &#123; return text.split(&apos;&apos;).reverse().join(&apos;&apos;); &#125; else if(typeof text === &apos;number&apos;) &#123; return +text.toString().split(&apos;&apos;).reverse().join(&apos;&apos;) &#125;&#125; 重复定义多次函数 reverse，前几次都是函数定义，最后一次是函数实现。 TypeScript与JavaScript的处理流程相似，它会查找重载列表，从第一个重载定义开始匹配，如果匹配的话就使用这个定义，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类 class同ES6 的 class 相关概念 类(Class)：定义了一件事物的抽象特点，包含它的属性和方法 对象（Object）：类的实例，通过 new 生成 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 Cat 和 Dog 都继承自 Animal，但是分别实现了自己的 eat 方法。此时针对某一个实例，我们无需了解它是 Cat 还是 Dog，就可以直接调用 eat 方法，程序会自动判断出来应该如何执行 eat 存取器（getter &amp; setter）：用以改变属性的读取和赋值行为 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 public 表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 类的定义使用 class 定义类，使用 constructor 定义构造函数。 通过 new 生成新实例的时候，会自动调用构造函数。 class Animal &#123; name:string; // 定义属性 constructor(name) &#123; this.name = name; // 属性赋值 &#125; sayHi() &#123; return `我叫 $&#123;this.name&#125;`; &#125;&#125;let cat = new Animal(&apos;Tom&apos;);console.log(cat.sayHi()); // 我叫 Tom 类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。 class Cat extends Animal &#123; color: string; constructor(name, color) &#123; super(name); // 调用父类Animal的 constructor(name) this.color = color &#125; sayHi() &#123; // 调用父类的 sayHi()； return super.sayHi() + &apos;我是一只&apos;+ this.color + &apos; 色的猫，&apos;; &#125;&#125;let c = new Cat(&apos;Tom&apos;, &apos;橘黄&apos;); // Tomconsole.log(c.sayHi()); // 我叫 Tom，我是一只橘黄色的猫；let cat2 = new Cat(&apos;Jerry&apos;);cat2.color = &apos;黑&apos;;console.log(c.sayHi()); // 我叫 Jerry，我是一只黑色的猫； 存取器使用 getter 和 setter 可以改变属性的赋值和读取行为： class Animal &#123; name:string; constructor(name) &#123; this.name = name; &#125; get name() &#123; return &apos;Jack&apos;; &#125; set name(value) &#123; console.log(&apos;setter: &apos; + value); &#125;&#125;let a = new Animal(&apos;Kitty&apos;); // setter: Kittya.name = &apos;Tom&apos;; // setter: Tomconsole.log(a.name); // Jack 实例属性和方法js中的属性和方法： // js中function Person(name) &#123; this.name = name; // 实例属性 this.eat = function()&#123; console.log(&apos;eat&apos;) &#125;; // 实例方法&#125;Person.age = 19; // 静态属性Person.sleep = function()&#123; console.log(&apos;sleep&apos;) &#125;; // 静态方法// 访问实例方法和属性:var tom = new Person(&apos;tom&apos;);console.log(tom.name) // tomtom.eat();tom.sleep() // error: tom.sleep is not a function// 访问静态方法和属性:console.log(Person.age); // 19Person.sleep();Person.eat(); // error: Person.eat is not a function ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义： class Animal &#123; constructor()&#123; this.name = &apos;tom&apos;; &#125; eat() &#123;&#125;&#125;let a = new Animal();console.log(a.name); // tom ES7 提案中可以直接在类里面定义： // tsclass Animal &#123; name = &apos;tom&apos;; eat() &#123;&#125;&#125;let a = new Animal();console.log(a.name); // Jack 静态属性和方法ES7 提案中，可以使用 static 定义一个静态属性或方法。静态方法不需要实例化，而是直接通过类来调用： // tsclass Animal &#123; static num = 42; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;console.log(Animal.num); // 42let a = new Animal(&apos;Jack&apos;);Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function 访问修饰符public公有属性或方法，可以在任何地方被访问到，默认所有的属性和方法都是 public的 private私有属性或方法，不能在声明它的类的外部访问，也不可以在子类中访问 protected受保护的属性或方法，它和 private 类似，区别是它可以在子类中访问 class Person &#123; public name:string; protected phone:number; private idCard:number; constructor(name,idCard,phone) &#123; this.name = name; this.idCard = idCard; this.phone = phone; &#125;&#125;let tom = new Person(&apos;tom&apos;,420000,13811110000);console.log(tom.name) // tomconsole.log(tom.phone)// error:Property &apos;phone&apos; is protected and only accessible within class &apos;Person&apos; and its subclassesconsole.log(tom.idCard) // error:Property &apos;idCard&apos; is private and only accessible within class &apos;Person&apos;.class Teacher extends Person &#123; constructor(name,idCard,phone) &#123; super(name,idCard,phone); console.log(this.name) console.log(this.phone) console.log(this.idCard) // error:Property &apos;idCard&apos; is private and only accessible within class &apos;Person&apos;. &#125;&#125; 多态同一个父类的多个子类，可以有不同结果的同名方法： class Person &#123; eat()&#123; console.log('eat') &#125;&#125;class A extends Person &#123; eat()&#123; console.log('A eat') &#125;&#125;class B extends Person &#123; eat()&#123; console.log('B eat') &#125;&#125; 抽象类/抽象方法 abstractabstract 用于定义抽象类和其中的抽象方法。 抽象类是提供给其他类继承的基类（父类），是不允许被实例化 抽象方法只能包含在抽象类中 子类继承抽象类，必须实现抽象类中的抽象方法 abstract class Animal &#123; abstract eat(); // 抽象方法 // 普通方法 sleep()&#123; console.log(&apos;sleep&apos;) &#125;&#125;let a = new Animal(); // 报错，抽象类不能被实例化class Cat extends Animal &#123; eat()&#123; // 父类的eat方法必须被实现 console.log(&apos;eat&apos;) &#125;&#125; 类与接口前面介绍了 接口 可以用来描述 对象(object)的形状，这一章主要介绍 接口 对 类(class)的行为 进行抽象。 类实现接口 implements实现（implements）是面向对象中的一个重要概念。一个类只能继承自另一个类，不同类之间可能会有一些共有特性，提取多个类的共有特性，作为一个接口，再用 implements 关键字来实现就可以大大提高面向对象的灵活性。 举例： 人是一个类，人需要吃东西。动物是一个类，动物也需要吃东西。这种情况就可以把 吃东西 提取出来作为一个接口： interface Ieat &#123; eat();&#125;class Person implements Ieat&#123; eat()&#123;&#125;&#125;class Animal implements Ieat &#123; eat()&#123;&#125;&#125; 一个类也可以实现多个接口： interface Ieat &#123; eat();&#125;interface Isleep &#123; sleep();&#125;class Person implements Ieat, Isleep&#123; eat()&#123;&#125; sleep() &#123;&#125;&#125; 接口继承接口interface Alarm &#123; alert();&#125;interface LightableAlarm extends Alarm &#123; lightOn(); lightOff();&#125; 接口继承类class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 混合类型前面介绍了接口可以用来定义函数的形状，有时候，一个函数还可以有自己的属性和方法： interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 打印number： function printer(arr:number[]):void &#123; for(var item of arr) &#123; console.log(item) &#125;&#125;printer([1,2,3,4]) 打印字符串： // 打印字符串function printer1(arr:string[]):void &#123; for(var item of arr) &#123; console.log(item) &#125;&#125;printer1(['a','b','c','d']) 使用 any 也可以通过编译，但是无法准确定义返回值的类型，这个时候就可以使用泛型函数 泛型函数在函数名后加上 &lt;T&gt; （也可以是其他别的字母），其中 T 用来指代输入的类型，在函数内部就可以使用这个 T 类型。 function printer&lt;T&gt;(arr:T[]):void &#123; for(var item of arr) &#123; console.log(item) &#125;&#125;// 指定具体类型调用printer&lt;string&gt;([&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]);// 调用时也可以直接让ts自己做类型推论printer([1,2,3,4]); 也可以同时使用多个类型参数 function swap&lt;S,P&gt;(tuple:[S,P]):[P,S] &#123; return [tuple[1], tuple[0]]&#125;swap&lt;string, number&gt;(['a', 2]) 泛型类class arrayList&lt;T&gt; &#123; name: T; list: T[] = []; add(val:T):void &#123; this.list.push(val) &#125;&#125;var arr = new arrayList&lt;number&gt;();arr.add(1)arr.add(2)console.log(arr.list) 泛型接口interface Iadd&lt;T&gt; &#123; (x:T,y:T):T;&#125;var add:Tadd&lt;number&gt; = function(x:number,y:number):number &#123; return x + y&#125; 泛型约束在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法 获取一个参数的长度： function getLength&lt;T&gt;(arg:T):T &#123; console.log(arg.length) // error: Property &apos;length&apos; does not exist on type &apos;T&apos; return arg;&#125; 上例中，泛型 T 不一定包含属性 length，所以编译的时候报错了，这时候就可以使用泛型约束，使用 extends 约束泛型 &lt;T&gt; 必须符合 Ilength 的形状，也就是必须包含 length 属性： interface Ilength &#123; length: number&#125;function getLength&lt;T extends Ilength&gt;(arg:T):T &#123; console.log(arg.length) return arg;&#125;getLength(&apos;abcd&apos;) // 4getLength(7) // error: Argument of type &apos;7&apos; is not assignable to parameter of type &apos;Ilength&apos;. 多个参数间也可以互相约束： function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;) 声明文件 declare当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。 声明语句假如我们使用第三方库 jQuery，来获取一个元素 $(&apos;#foo&apos;);jQuery(&apos;#foo&apos;); 但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西： jQuery(&apos;#foo&apos;);// ERROR: Cannot find name &apos;jQuery&apos;. 这时，我们需要使用 declare var 来定义它的类型，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。 declare var jQuery: (selector: string) =&gt; any;jQuery(&apos;#foo&apos;); 声明文件通常我们会把声明语句放到一个单独的文件（xxx.d.ts）中，这就是声明文件，声明文件必需以 .d.ts 为后缀。 一般来说，ts 会解析项目中所有的 *.ts 文件，当然也包含以 .d.ts 结尾的文件。所以当我们将 jQuery.d.ts 放到项目中时，其他所有 *.ts 文件就都可以获得 jQuery 的类型定义了。 这是使用全局变量模式的声明文件，还有其他模式如 模块导入 等会在后面介绍。 第三方声明文件社区已经帮我们定义好了很多第三方库的声明文件，可以直接下载下来使用，更推荐使用 @types 统一管理第三方库的声明文件。@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例： npm install @types/jquery --save-dev 可以在这个页面搜索你需要的声明文件。 书写声明文件当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。 在不同的场景下，声明文件的内容和使用方式会有所区别： 全局变量：通过 &lt;script&gt; 标签引入第三方库，注入全局变量 npm 包：通过 import foo from &#39;foo&#39; 导入，符合 ES6 模块规范 UMD 库：既可以通过 &lt;script&gt; 标签引入，又可以通过 import 导入 模块插件：通过 import 导入后，可以改变另一个模块的结构 直接扩展全局变量：通过 &lt;script&gt; 标签引入后，改变一个全局变量的结构。比如为 String.prototype 新增了一个方法 通过导入扩展全局变量：通过 import 导入后，可以改变一个全局变量的结构 全局变量未完待续 。。。 感谢 TypeScript 入门教程 TS 官方文档中文 阮一峰ECMAScript 6 入门]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows常用系统命令]]></title>
    <url>%2F2019%2F02%2F25%2Fwindows-command%2F</url>
    <content type="text"><![CDATA[Windows Command 常用的 windows 系统命令 win + r 打开运行窗口，输入 cmd，回车确定，进入命令窗口 系统程序 winver —— 检查Windows版本 ver —— 显示 Windows 版本 mspaint—— 画图板 calc —— 计算器 magnify —— 放大镜 mmc —— 打开控制台 notepad —— 新建记事本 tsshutdn —— 60秒倒计时关机命令 rononce -p ——15秒关机 taskmgr —— 任务管理器 explorer —— 打开资源管理器 ping —— 查看不同的网络是否通畅 ping 主机ip或名字 netstat -ano —— 查看当前网络连接状态 cls —— 清除当前窗口内容 date —— 显示或设置日期 time– 显示或设置时间 start —— 新开一个命令窗口 ipconfig —— 查看本机 IP 配置 文件操作 关于文件路径（path）统一使用如下语法 [盘符:\] [路径\]g:\test\folder\test.txt C: —— 输入盘符，进入顶级目录 // 进入D盘D: cd —— 进入目录命令 进入目录时，输入文件夹首字母，按 Tab 键可自动填充和切换目录 // 返回上一级目录cd ..// 进入test文件夹cd test dir —— 显示当前目录下的文件及文件夹 copy path\fileName newPath\newFileName —— 复制文件 path为空时，表示当前目录下的文件 move path\fileName newPath\newFileName —— 移动文件到newPath del fileName —— 删除文件或清空文件夹 del 后面是文件名时，将删除该文件，后面是文件夹名称时，将删除该文件夹下的所有子文件 mkdir folderName —— 创建文件夹 // 完整命令： md [盘符:\] [路径\]md g:\test\newFolder md —— mkdir 的缩写 rmdir —— 删除文件夹 只能删除空文件夹，如果要强制删除加上 /s 就可以直接删除，删除过程会提示确定，添加 /q 即安静模式（quiet）, 便可直接删除 // 强制删除G盘下 test 文件夹下的 newFolder 文件夹rd /s /q g:\test\newFolder rd —— rmdir的缩写 `rename oldName newName —— 重命名文件或文件夹 ren —— rename的缩写 type —— 显示文本文件的内容 type nul&gt;fileName —— 创建空文件 echo [fileContent]&gt;fileName —— 创建非空文件]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动条美化]]></title>
    <url>%2F2019%2F02%2F25%2Fscrollbar%2F</url>
    <content type="text"><![CDATA[浏览器默认的滚动条样式非常感人，追求完美的产品当然不会放过这一细节，以下便给出通过CSS修改滚动条样式的代码。 demo演示 谷歌浏览器： /* 修改滚动条颜色和宽度 必须的样式 */::-webkit-scrollbar &#123; width: 10px; /* 纵向滚动条宽度 */ height: 10px; /* 横向滚动条高度 */ border: 2px solid purple; border-radius: 5px; background-color: cadetblue;&#125;/* 滑块样式 */::-webkit-scrollbar-thumb &#123; border: 2px solid #000; border-radius: 5px; background: #fff;&#125;/* 滚动条外层轨道样式，相同属性的样式会被内层轨道样式遮盖 */::-webkit-scrollbar-track &#123; border: 2px solid gold; background-color: rgb(25, 214, 25)&#125;/* 滚动条内层轨道样式 */::-webkit-scrollbar-track-piece &#123; border-radius: 5px; border: 2px solid #fff; background-color: #000;&#125;/* 滚动条两端的按钮样式 */::-webkit-scrollbar-button &#123; width: 50px; height: 50px; border: 2px solid red; border-radius: 5px; background: gold;&#125;/* 横向滚动条和纵向滚动条交汇处样式 */::-webkit-scrollbar-corner &#123; background-color: red; border: 2px solid green; border-radius: 5px;&#125; IE浏览器 也可作出部分修改： .scroll &#123; /* 设置滚动条主要构成部分的颜色 */ scrollbar-base-color: red; /* 滑块颜色 */ scrollbar-face-color: #000; /* 滑块边框 */ scrollbar-shadow-color: red; /* 设置滚动条两端箭头的颜色 */ scrollbar-arrow-color: red; /* 滚动条轨道颜色 */ scrollbar-track-color:green; /* 设置滚动框的和滚动条箭头左上边缘的颜色 不生效 */ scrollbar-highlight-color:blue; /* 设置滚动框的和滚动条箭头左上边缘的颜色 不生效 */ scrollbar-3dlight-color:blue; /* 设置滚动条槽的颜色 不生效 */ scrollbar-darkshadow-color:blue; &#125;]]></content>
      <categories>
        <category>HTML/CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Router v4.x API]]></title>
    <url>%2F2018%2F11%2F22%2FReactRouter4%2F</url>
    <content type="text"><![CDATA[react-router v4.x APIreact-router 4.x WEB 版本官网意译，如有不对的地方，欢迎指正。 BrowserRouterimport &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;&lt;BrowserRouter basename=&#123;optionalString&#125; forceRefresh=&#123;optionalBool&#125; getUserConfirmation=&#123;optionalFunc&#125; keyLength=&#123;optionalNumber&#125;&gt; &lt;App/&gt;&lt;/BrowserRouter&gt; basename: string ​ 当前位置的基准 URL。如果你的页面部署在服务器的二级（子）目录，你需要将 basename 设置到此子目录。 正确的 URL 格式是前面有一个前导斜杠，但不能有尾部斜杠。 getUserConfirmation: fun ​ 当导航需要确认时执行的函数 forceRefresh: bool ​ 当设置为 true 时，在导航的过程中整个页面将会刷新。 只有当浏览器不支持 HTML5 的 history API 时，才设置为 true。 keyLength: number ​ location.key 的长度。默认是 6 children: node ​ 渲染 单一 子组件（元素）。 Linkimport &#123; Link &#125; from 'react-router-dom'&lt;Link to="/about"&gt;关于&lt;/Link&gt;&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt; to: string/object ​ 需要跳转到的路径(pathname)或地址（location）。 replace: bool ​ 当设置为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址。当设置为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false。 NavLink ​ 一种特殊的，会给当前的URL匹配到元素加上style属性 ​ A special version of the that will add styling attributes to the rendered element when it matches the current URL. import &#123; NavLink &#125; from &apos;react-router-dom&apos;&lt;NavLink to=&quot;/about&quot;&gt;About&lt;/NavLink&gt; activeClassName: string ​ 激活时的类名 ​ The class to give the element when it is active. The default given class is active. This will be joined with the className prop. activeStyle: object ​ 激活的样式 ​ The styles to apply to the element when it is active. exact: bool ​ 严格匹配location’s pathname ​ When true, the active class/style will only be applied if the location is matched exactly. strict: bool ​ 是否考虑 location’s pathname 末尾的斜杠 ​ When true, the trailing slash on a location’s pathname will be taken into consideration when determining if the location matches the current URL. See the documentation for more information. isActive: func ​ 激活时可选的额外逻辑处理 ​ A function to add extra logic for determining whether the link is active. This should be used if you want to do more than verify that the link’s pathname matches the current URL’s pathname。 Redirect ​ 重定向 ​ Rendering a &lt;Redirect&gt; will navigate to a new location. The new location will override the current location in the history stack, like server-side redirects (HTTP 3xx) do. import &#123; Route, Redirect &#125; from &apos;react-router&apos;&lt;Route exact path=&quot;/&quot; render=&#123;() =&gt; ( loggedIn ? ( &lt;Redirect to=&#123;&#123; pathname: &apos;/login&apos;, search: &apos;?utm=your+face&apos;, state: &#123; referrer: currentLocation &#125; &#125;&#125; /&gt; ) : ( &lt;PublicHomePage/&gt; ))&#125;/&gt;&lt;Redirect to=&quot;/somewhere/else&quot;/&gt; to: string/object 需要重定向的路径(pathname)或地址（location）。 The URL to redirect to / A location to redirect to push: bool ​ When true, redirecting will push a new entry onto the history instead of replacing the current one. &lt;Redirect push to=&quot;/somewhere/else&quot;/&gt; from: string ​ 当使用&lt; switch &gt; 时 可以指定需要重定向的页面 ​ A pathname to redirect from. This can be used to match a location when rendering a &lt;Redirect&gt; inside of a &lt;Switch&gt; &lt;Redirect from=&apos;/old-path&apos; to=&apos;/new-path&apos;/&gt; &lt;Route path=&apos;/new-path&apos; component=&#123;Place&#125;/&gt;&lt;/Switch&gt; Route ​ The Route component is perhaps the most important component in React Router to understand and learn to use well. Its most basic responsibility is to render some UI when a location matches the route’s path. import &#123; BrowserRouter as Router, Route &#125; from &apos;react-router-dom&apos;&lt;Router&gt; &lt;div&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/news&quot; component=&#123;NewsFeed&#125;/&gt; &lt;/div&gt;&lt;/Router&gt;// &quot;/&quot;:&lt;div&gt; &lt;Home/&gt; &lt;!-- react-empty: 2 --&gt;&lt;/div&gt;// &quot;/news&quot;:&lt;div&gt; &lt;!-- react-empty: 1 --&gt; &lt;NewsFeed/&gt;&lt;/div&gt; Route render methods ​ 渲染Route组件的三种方式 ​ There are 3 ways to render something with a &lt; Route &gt;, Each is useful in different circumstances. You should use only one of these props on a given &lt; Route &gt;. See their explanations below to understand why you have 3 options. Most of the time you’ll use component. &lt; Route component &gt; &lt; Route render &gt; &lt; Route children &gt; component A React component to render only when the location matches. It will be rendered with route props. ​ 当你使用component方式时，Route组件将使用 React.createElement 创建一个新的组件，这意味着，如果你使用了内联函数，组件将会卸载多次，当然你并不希望这样。因此对于内联组件，使用render属性会更好。 ​ When you use component (instead of render, below) the router uses React.createElement to create a new React element from the given component. That means if you provide an inline function you will get a lot of undesired remounting. For inline rendering, use the render prop (below). &lt;Route path=&quot;/user/:username&quot; component=&#123;User&#125;/&gt;const User = (&#123; match &#125;) =&gt; &#123; return &lt;h1&gt;Hello &#123;match.params.username&#125;!&lt;/h1&gt;&#125; render: function ​ ​ This allows for convenient inline rendering and wrapping without the undesired remounting explained above.Instead of having a new React element created for you using the component prop, you can pass in a function to be called when the location matches. The render prop receives all the same route props as the component render prop. Warning: &lt; Route component &gt; takes precendence over &lt; Route render &gt; so don’t use both in the same &lt; Route &gt; . // convenient inline rendering&lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;// wrapping/composingconst FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; ( &lt;Route &#123;...rest&#125; render=&#123;props =&gt; ( &lt;FadeIn&gt; &lt;Component &#123;...props&#125;/&gt; &lt;/FadeIn&gt; )&#125;/&gt;)&lt;FadingRoute path=&quot;/cool&quot; component=&#123;Something&#125;/&gt; children: function ​ Sometimes you need to render whether the path matches the location or not. In these cases, you can use the function children prop. It works exactly like render except that it gets called whether there is a match or not. ​ The children render prop receives all the same route props as the component and render methods, except when a route fails to match the URL, then match is null. This allows you to dynamically adjust your UI based on whether or not the route matches. Here we’re adding an active class if the route matches Warning: Both and take precendence over so don’t use more than one in the same &lt;Route&gt;. &lt;ul&gt; &lt;ListItemLink to=&quot;/somewhere&quot;/&gt; &lt;ListItemLink to=&quot;/somewhere-else&quot;/&gt;&lt;/ul&gt;const ListItemLink = (&#123; to, ...rest &#125;) =&gt; ( &lt;Route path=&#123;to&#125; children=&#123;(&#123; match &#125;) =&gt; ( &lt;li className=&#123;match ? &apos;active&apos; : &apos;&apos;&#125;&gt; &lt;Link to=&#123;to&#125; &#123;...rest&#125;/&gt; &lt;/li&gt; )&#125;/&gt;)// This could also be useful for animations:&lt;Route children=&#123;(&#123; match, ...rest &#125;) =&gt; ( &#123;/* Animate will always render, so you can use lifecycles to animate its child in and out */&#125; &lt;Animate&gt; &#123;match &amp;&amp; &lt;Something &#123;...rest&#125;/&gt;&#125; &lt;/Animate&gt;)&#125;/&gt; Route props 每个组件都会传递三个属性：match、location、history All three render methods will be passed the same three route props match location history path: string ​ Any valid URL path that path-to-regexp understands. &lt;Route path=&quot;/users/:id&quot; component=&#123;User&#125;/&gt; ​ Routes without a path always match. exact: bool ​ When true, will only match if the path matches the location.pathname exactly. path location.pathname exact matches? /one /one/two true no /one /one/two false yes strict: bool ​ When true, a path that has a trailing slash will only match a location.pathname with a trailing slash. This has no effect when there are additional URL segments in the location.pathname. 警告: strict模式可以辨别 location.pathname 末尾的 ‘/‘ ，但是为了确保精确匹配，必须同时使用strict模式和exact模式。 Warning: strict can be used to enforce that a location.pathname has no trailing slash, but in order to do this both strict and exact must be true. path location.pathname strict? matches /one/ /one true no /one/ /one/ true yes /one/ /one/two true yes Router ​ react-router最基础的使用方式，也是所有路由器的常见的底层接口组件。一般的应用程序将使用一个高层的路由器 ​ The common low-level interface for all router components. Typically apps will use one of the high-level routers instead history: object ​ A history object to use for navigation. import createBrowserHistory from &apos;history/createBrowserHistory&apos;const customHistory = createBrowserHistory()&lt;Router history=&#123;customHistory&#125;/&gt; children: node ​ A single child element to render. &lt;Router&gt; &lt;App/&gt;&lt;/Router&gt; Switch Renders the first child &lt;Route&gt; or &lt;Redirect&gt; that matches the location ​ Renders the first child &lt;Route&gt; or &lt;Redirect&gt; that matches the location.How is this different than just using a bunch of &lt;Route&gt;s ? &lt;Switch&gt; is unique in that it renders a route exclusively. In contrast, every &lt;Route&gt; that matches the location renders inclusively. Consider this code: &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;&lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;&lt;Route component=&#123;NoMatch&#125;/&gt; ​ If the URL is /about, then &lt;About&gt;, &lt;User&gt;, and &lt;NoMatch&gt; will all render because they all match the path. This is by design, allowing us to compose &lt;Route&gt;s into our apps in many ways, like sidebars and breadcrumbs, bootstrap tabs, etc.Occasionally, however, we want to pick only one &lt;Route&gt; to render. If we’re at /about we don’t want to also match /:user (or show our “404” page). Here’s how to do it with Switch: import &#123; Switch, Route &#125; from &apos;react-router&apos;&lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt; ​ Now, if we’re at /about, &lt;Switch&gt; will start looking for a matching &lt;Route&gt;. &lt;Route path=&quot;/about&quot;/&gt; will match and &lt;Switch&gt; will stop looking for matches and render &lt;About&gt;. Similarly, if we’re at /michael then &lt;User&gt; will render.This is also useful for animated transitions since the matched &lt;Route&gt; is rendered in the same position as the previous one. ​ This is also useful for animated transitions since the matched is rendered in the same position as the previous one. &lt;Fade&gt; &lt;Switch&gt; &#123;/* there will only ever be one child here */&#125; &lt;Route/&gt; &lt;Route/&gt; &lt;/Switch&gt;&lt;/Fade&gt;&lt;Fade&gt; &lt;Route/&gt; &lt;Route/&gt; &#123;/* there will always be two children here, one might render null though, making transitions a bit more cumbersome to work out */&#125;&lt;/Fade&gt; children: node ​ All children of a should be or elements. Only the first child to match the current location will be rendered. elements are matched using their path prop and elements are matched using their from prop. A with no path prop or a with no from prop will always match the current location. &lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/users&quot; component=&#123;Users&#125;/&gt; &lt;Redirect from=&quot;/accounts&quot; to=&quot;/users&quot;/&gt; &lt;Route component=&#123;NoMatch&#125;/&gt;&lt;/Switch&gt; historylocation// usually all you need&lt;Link to=&quot;/somewhere&quot;/&gt;// but you can use a location insteadconst location = &#123; pathname: &apos;/somewhere&apos;, search: &apos;?some=search-string&apos;, state: &#123; fromDashboard: true &#125;&#125;&lt;Link to=&#123;location&#125;/&gt;&lt;Redirect to=&#123;location&#125;/&gt;history.push(location)history.replace(location) matchmatchPath ​ This lets you use the same matching code that uses except outside of the normal render cycle, like gathering up data dependencies before rendering on the server. import &#123; matchPath &#125; from &apos;react-router&apos;const match = matchPath(&apos;/users/123&apos;, &#123; path: &apos;/users/:id&apos; exact: true, strict: false&#125;) pathname ​ The first argument is the pathname you want to match. If you’re using this on the server with Node.js, it would be req.url. props ​ The second argument are the props to match against, they are identical to the matching props Route accepts: withRouter ​ You can get access to the history object’s properties and the closest &lt;Route&gt;‘s match via the withRouter higher-order component. withRouter will re-render its component every time the route changes with the same props as&lt;Route&gt; render props: { match, location, history }.]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-ssh设置]]></title>
    <url>%2F2018%2F11%2F21%2Fgit-ssh%2F</url>
    <content type="text"><![CDATA[​ Windows环境 在使用多个 git 账号的时候，默认只能配置 1 个 git 账号，这就导致在使用其他账号进行 git 操作时每次都需要输入用户名和密码，本文记录了在 win7 配置多个 ssh-key 来管理 git 账号的过程，以下以配置 github 账号 为例。 打开 git bash， 输入 ssh-keygen -t rsa -C &lt;email&gt; 生成 SSH Key； ssh-keygen -t rsa -C 468905342@qq.com 输入文件名称保存 key，例：id_rsa_github； 输入密码并确认密码，此处建议直接回车（不设置密码），如果设置了密码，在以后的 git 的操作中还是需要输入密码才能继续操作。另外，在这里输入密码是没有任何显示和提示的，wtf ?!，我第一次操作的时候输入了密码，结果没有任何反应，我还以为是程序出错了。脑补你输入的密码，按 Enter 键二次输入确认密码，设置成功。以后你在 git 操作的时候输入密码时也是没有提示的。 上述操作成功后会在你打开 git bash 的目录生成2个文件（id_rsa_github 和 id_rsa_github.pub），拷贝这2个文件到 git .ssh 的默认目录，Windows在 C:\Users\Administrator\.ssh ，config 文件是在下一步手动创建的，known_hosts文件是后续自动生成的，如下图： 在 .ssh 目录下创建一个 config 文本文件，添加相关配置； 每个账号单独配置一个 Host，Host 要取一个别名（aliasName），别名在检测配置时需要用到，其他主要配置 HostName 和 IdentityFile 两个属性即可。 config文件配置如下： # 配置 github.comHost github.com HostName github.com IdentityFile C:\Users\Administrator\.ssh\\id_rsa_github PreferredAuthentications publickey User 468905342@qq.com # 配置 HostHost &lt;aliasName&gt; HostName 真实的域名地址 IdentityFile id_rsa的存放地址 PreferredAuthentications 配置登录时用什么权限认证：publickey， password publickey， keyboardinteractive User 配置使用用户名 检测配置，输入 ssh -T git@&lt;aliasName&gt; ，以下图示命令行的 github.com 即为上一步config配置文件中设置的Host的别名： 配置成功后，需要到你的 github 配置 SSH。 打开 github 官网并登录，右上角点击你的图标，选择 Settings -&gt; 选择 SSH and GPG keys -&gt; 点击 New SSH key，复制上述生成文件 id_rsa_github.pub 的内容，粘贴到 Key 一栏中，Title 一栏可以随意填写： 上述操作完成后，回到你的 github 本地仓库，此时进行 push 操作提示需要输入密码，因为还没有将远程仓库地址改为 ssh 地址。 在 github 仓库中复制仓库的 ssh 地址： 修改远程仓库地址 输入 git remote set-url origin &lt;ssh_url&gt; 此时在进行 git push 操作就不需要输入密码了。 以后再拉 github 仓库的时候选择 Clone with SSH（第10步），push 的时候就免去输入密码的烦恼啦。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客指南]]></title>
    <url>%2F2018%2F11%2F20%2Fhexo-note%2F</url>
    <content type="text"><![CDATA[Hexohexo简介为了描述方便，在以下说明中，我们约定 站点配置文件 和 主题配置文件 两个不同配置文件的名称。 站点配置文件根目录下的 _config.yml文件，主要包含 Hexo 本身的配置。 主题配置文件主题（theme）目录下的 _config.yml文件，这份配置由主题作者提供，主要用于配置主题相关的选项。 常用命令 启动服务器，默认访问网址为： http://localhost:4000/ // 预览 _post 文件夹hexo server// 预览 _post 和 _drafts 文件夹hexo server --drafts 清除缓存文件 ( db.json ) 和已生成的静态文件 ( public ) // 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。hexo clean 新建文章 hexo new [layout] &lt;title&gt; 新建草稿 hexo new draft test 发布草稿 hexo publish test 生成静态文件 hexo generate// 静态文件热更新// 监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入hexo generate --watch 部署 （发布） hexo deploy// 以下均可hexo generate --deployhexo deploy --generate// 简写hexo g -dhexo d -g hexo安装安装前提在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，按照下述步骤即可新建一个项目，如果未安装，请先按照官方指示 完成安装。 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 全局安装hexo脚手架（已安装过的请忽略这一步） npm install -g hexo-cli 建站创建项目安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 创建一个hexo项目 hexo init hexodemo进入项目根目录 cd hexodemo安装依赖包 npm install 新建完成后，指定文件夹的目录如下： .├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。 例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。 除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。 Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。 设置主题 hexo 默认主题为 landscape， 下载主题可以通过以下2种方式下载主题： git 安装 好处：可以通过 git pull 快速更新主题 进入项目根目录 cd hexodemo克隆安装包 git clone https://github.com/iissnan/hexo-theme-next themes/next 压缩包安装 前往 NexT 版本 发布页面。 选择你所需要的版本，下载 Download 区域下的 Source Code (zip) 到本地。 解压所下载的压缩包至站点的 themes 目录下， 并将 解压后的文件夹名称（hexo-theme-next-0.4.0）更改为 next。 启用主题打开 站点配置文件 ， 找到 theme 字段，并将其值更改为 next。 theme: next 主题配置├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #自定义模板| | ├── _header.swig #自定义网站页头，追加在页头模板之后| | ├── _sidebar.swig #自定义侧边栏| ├── _macro #可以自己修改的模板，覆盖原有模板| ├── ├── post-collapse.swig #文章合并，在归档、分类、标签模板中引用| ├── ├── post-copyright.swig #文章版权协议模板| | ├── post.swig #文章（正文和首页）模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| | ├── wechat-subscriber.swig #微信公众号模板| ├── _partial #局部的布局| | ├── head #&lt;head&gt;标签模板| | | ├── custom-head.swig #追加在&lt;head&gt;标签末尾| | | ├── external-fonts.swig #外部字体模板| | ├── search #本地搜索模板| | | ├── xxxx.swig #不同类型的搜索模板| | ├── share #分享模板| | | ├── xxxx.swig #不同类型的分享模板| | ├── comments.swig #评论模板| | ├── footer.swig #网站页脚模板| | ├── head.swig #&lt;head&gt;标签模板| | ├── header.swig #网站页头模板（导航栏等等模块）| | ├── page-header.swig #页面头部模板| | ├── pagination.swig #分页器模板| | ├── search.swig #搜索模板入口| ├── _scripts #脚本语言文件夹| ├── _third-party #第三方模板文件夹| | ├── analytics #统计分析相关的模板| | ├── comments #评论相关的模板| | ├── search #搜索相关的模板| | ├── seo #搜索引擎优化相关的模板| | ├── xxx.swig #其它，可根据文件名称辨认| ├── _layout.swig #主页模板| ├── archive.swig #归档页模板| ├── category.swig #分类页模板| ├── index.swig #post主体模板| ├── page.swig #页面模板| └── tag.swig #标签页模板├── scripts #script源码| ├── tags #Hexo内置标签插件源码| ├── marge.js #页面模板├── source #资源源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md 配置相关阅读全文1. 【推荐】在文章中适当位置插入 &lt;!--more--&gt; 手动截断，该位置之前的部分即为摘要，会显示在首页中； 2. 在文章的 front-matter 中添加 description，并提供文章摘录； 3. 自动形成摘要，在 主题配置文件 中添加，根据设置的 length 截断作为摘要。 auto_excerpt: enable: true length: 150 本地搜索1. 安装 hexo-generator-searchdb npm install hexo-generator-searchdb --save 2. 编辑 站点配置文件 文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 3. 编辑 主题配置文件 ，启用本地搜索功能： # Local searchlocal_search: enable: true]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock.js]]></title>
    <url>%2F2018%2F11%2F09%2F2018-11-09-Mock.JS%2F</url>
    <content type="text"><![CDATA[Mock.js简介Mock.js 是一款模拟数据生成器，旨在帮助前端攻城师独立于后端进行开发，帮助编写单元测试。 示例：http://mockjs.com/examples.html文档：http://mockjs.com/0.1/ 功能： 基于 数据模板 生成 模拟数据； 类型丰富的 随机数据 模拟 Ajax 请求 语法规范 Mock.js 的语法规范包括两部分： 数据模板定义（Data Temaplte Definition，DTD） 数据占位符定义（Data Placeholder Definition，DPD） 数据模板定义 DTD 数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： 属性名|生成规则：属性值&apos;name|rule&apos;: value 生成规则 属性名 和 生成规则 之间用 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： 1. &apos;name|min-max&apos;: value2. &apos;name|count&apos;: value3. &apos;name|min-max.dmin-dmax&apos;: value4. &apos;name|min-max.dcount&apos;: value5. &apos;name|count.dmin-dmax&apos;: value6. &apos;name|count.dcount&apos;: value7. &apos;name|+step&apos;: value 生成规则的含义需要依赖 属性值 才能确定。 属性值中可以含有 @占位符。 属性值还指定了最终值的初始值和类型。 String : 属性值为字符串 &#39;name|min-max&#39;: string 重复字符串 string 生成一个字符串，重复次数大于等于 min，小于等于 max // 生成 1 ~ 10 个 &quot;★&quot;Mock.mock(&#123; &quot;string|1-10&quot;: &quot;★&quot;&#125;)// ==&gt; &#123; &quot;string&quot;: &quot;★★★★&quot; &#125; &#39;name|count&#39;: string 重复字符串 string 生成一个字符串，重复次数等于count // 重复 &quot;String&quot; 3 次Mock.mock(&#123; &quot;string|3&quot;: &quot;String&quot;,&#125;)// ==&gt; &#123; &quot;string&quot;: &quot;StringStringString&quot; &#125; Number : 属性值为数字 &#39;name|min-max&#39;: number 生成一个大于等于 min、小于等于 max 的整数，属性值 number只用来确定Number类型 // 生成一个整数，区间：[1,10]Mock.mock(&#123; &quot;number|1-10&quot;: 100&#125;)// ==&gt; &#123; &quot;number&quot;: 6 &#125; &#39;name|min-max.dmin-dmax&#39;: number 生成一个浮点数，整数部分大于等于min、小于等于 max，小数部分保留 dmin 到 dmax 位，属性值 value 只用来确定Number类型 // number1: 生成一个小数，整数区间：[1,10], 小数部分保留 2 到 4 位// number2: 生成一个小数，整数部分为10, 小数部分保留 2 到 4 位// number3: 生成一个小数，整数部分为10, 小数部分保留 2 位Mock.mock(&#123; &quot;number1|1-10.2-4&quot;: 100, &quot;number2|10.2-4&quot;: 100, &quot;number3|10.2&quot;: 100,&#125;)// =&gt; &#123; &quot;number1&quot;: 6.123, &quot;number2&quot;: 10.2884, &quot;number3&quot;: 10.68,&#125; &#39;name|+step&#39;: number 属性值以 step 递增，初始值为 number， step不能为负值 tip: 官网示例关于Number的这一条示例没看懂，摸不清Result的刷新规则，但对于数组中应从此规则是很好理解的，示例如下： // 生成一个数组list, 每一项的id 自增 5 ，初始值为100Mock.mock(&#123; &quot;list|3&quot;: [ &#123;&quot;id|+5&quot;: 100&#125; ],&#125;)// =&gt; &#123;&quot;list&quot;: [ &#123;id: 100&#125;, &#123;id: 105&#125;, &#123;id: 110&#125;,]&#125; Boolean：属性值为布尔值 &#39;name|1&#39;: boolean 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2 // 生成一个布尔值, 1/2为true, 1/2为falseMock.mock(&#123; &quot;boolean|1&quot;: true,&#125;)// =&gt; &#123; &quot;boolean&quot;: false &#125; &#39;name|min-max&#39;: boolean 随机生成一个布尔值，值为 boolean 的概率是 min / (min + max)，值为 !boolean 的概率是 max / (min + max) // 生成一个布尔值, 1/3为false, 2/3为trueMock.mock(&#123; &quot;boolean|1-2&quot;: false,&#125;)// =&gt; &#123; &quot;boolean&quot;: false &#125; Object：属性值为对象 Object &#39;name|min-max&#39;: object 从属性值 object 中随机选取 min 到 max 个属性。 // 生成一个对象, 包含 1 ~ 2 个属性Mock.mock(&#123; &quot;object|1-2&quot;: &#123; &quot;name&quot;: &quot;code&quot;, &quot;gender&quot;: 1, &quot;age&quot;: 18, &quot;tel&quot;: &quot;18911112222&quot; &#125;&#125;)// =&gt; &#123;object: &#123; &quot;name&quot;: &quot;code&quot;,&#125;&#125; &#39;name|count&#39;: object 从属性值 object 中随机选取 count 个属性。 // 生成一个对象, 包含 2 个属性Mock.mock(&#123; &quot;object|2&quot;: &#123; &quot;name&quot;: &quot;code&quot;, &quot;gender&quot;: 1, &quot;age&quot;: 18, &quot;tel&quot;: &quot;18911112222&quot; &#125;&#125;)// =&gt; &#123;object: &#123; &quot;name&quot;: &quot;code&quot;, &quot;age&quot;: 18,&#125;&#125; Array : 属性值为数组 &#39;name|1&#39;: array 从属性值 array 中随机选取 1 个元素，作为最终值 Mock.mock(&#123; &quot;array|1&quot;: [1,2,3,4]&#125;)// =&gt; &#123; array: 1 &#125; &#39;name|count&#39;: array 通过重复属性值 array 生成一个新数组，重复次数为 count Mock.mock(&#123; &quot;array1|2&quot;: [1,2,3], &quot;array2|2&quot;: [&#123;a:1&#125;,2],&#125;)// =&gt; &#123; array1: [ 1, 2, 3, 1, 2, 3 ], array2: [ &#123;a:1&#125;, 2, &#123;a:1&#125;, 2 ]&#125; `’name|min-max’: array 通过重复属性值 array 生成一个新数组，重复次数大于等于 min，小于等于 max Mock.mock(&#123; &quot;array|1-3&quot;: [&#123;id:1, name: 2&#125;],&#125;)// =&gt; &#123;array1: [ &#123;id:1, name: 2&#125;, &#123;id:1, name: 2&#125; ]&#125; &#39;name|+step&#39;: array 从下标 0 的位置循环取出array中的元素， 下标以 step 递增并对 array.length 取余 Mock.mock(&#123; &quot;array|4&quot;: [&#123; &quot;number|+1&quot;: [2,4] &#125;]&#125;)// =&gt; &#123;array: [ &#123; number: 2&#125;, &#123; number: 4&#125;, &#123; number: 2&#125;, &#123; number: 4&#125;]&#125; Function：属性值为函数 &#39;name&#39;: function(){} 取函数返回值作为最终的属性值，上下文为 &#39;name&#39; 所在的对象。 Mock.mock(&#123; &apos;firstName&apos;: &apos;Guoda&apos;, &apos;name&apos;: function() &#123; var nameObj = Mock.mock(&#123; &apos;firstName&apos;: &apos;Jason&apos;, &apos;lastName&apos;: &apos;Statham&apos;, &apos;name&apos;: function() &#123; // 这里的 this.firstName 会取到 &apos;Jason&apos; 而不会取到 &apos;Guoda&apos; return this.firstName + &quot; &quot; +this.lastName; &#125; &#125;) return nameObj.name &#125;&#125;)// =&gt; &#123; &quot;firstName&quot;: &quot;Guoda&quot;, &quot;name&quot;: &quot;Jason Statham&quot;&#125; RegExp： 属性值为正则表达式 &#39;name&#39;: regexp Mock.mock(&#123; &apos;regexp1&apos;: /[a-z][A-Z][0-9]/, &apos;regexp2&apos;: /\d&#123;5,10&#125;/ &apos;regexp3|1-5&apos;: /\d&#123;5,10&#125;\-/, &apos;regexp4|3&apos;: /\d&#123;2,4&#125;\*/&#125;)// =&gt; &#123; &quot;regexp1&quot;: &quot;cD3&quot;, &quot;regexp2&quot;: &quot;54833&quot;, &quot;regexp3&quot;: &quot;597425-8412964-5862207-7615212-051289-582018-&quot;, &quot;regexp4&quot;: &quot;374*1397*88*027*&quot;,&#125; Path： 属性值通过路径获取 Relative Path 相对路径 相对于当前属性名的路径 var relativePathData = Mock.mock(&#123; &quot;foo&quot;: &quot;Hello&quot;, &quot;nested&quot;: &#123; &quot;a&quot;: &#123; &quot;b&quot;: &#123; &quot;c&quot;: &quot;Mock.js&quot; &#125; &#125; &#125;, &quot;relativePath&quot;: &#123; &quot;a&quot;: &#123; &quot;b&quot;: &#123; &quot;c&quot;: &quot;@../../../foo @../../../nested/a/b/c&quot; &#125; &#125; &#125;&#125;)console.log(relativePathData.relativePath)// =&gt; &quot;Hello Mock.js&quot; Absolute Path 绝对路径 最外层为根路径 var absolutePathData = Mock.mock(&#123; &quot;foo&quot;: &quot;Hello&quot;, &quot;nested&quot;: &#123; &quot;a&quot;: &#123; &quot;b&quot;: &#123; &quot;c&quot;: &quot;Mock.js&quot; &#125; &#125; &#125;, &quot;absolutePath&quot;: &quot;@/foo @/nested/a/b/c&quot;&#125;)console.log(absolutePathData.absolutePath)// =&gt; &quot;Hello Mock.js&quot; 数据占位符定义 DPD 占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中 用 @ 来标识其后的字符串是 占位符 占位符 引用的是 Mock.Random 中的方法，建议引用时 方法名 全大写，以便在阅读时从视觉上提高占位符的识别度，快速识别占位符 和 普通字符 通过 Mock.Random.extend() 来扩展自定义占位符 占位符 也可以引用 数据模板 中的属性 占位符 会优先引用 数据模板 中的属性 占位符 支持 相对路径 和 绝对路径。 // @FIRST 和 @first 均可调用 Mock.Random.first()， 使用大写易于区分占位符和字符串Mock.mock(&#123; &quot;name&quot;: &#123; first: &apos;@FIRST&apos;, // @FIRST 引用 Mock.Random.first() last: &apos;@LAST&apos;, // @LAST 引用 Mock.Random.last() full: &apos;@first @last&apos; // @first 优先引用数据模版的属性（this.first） &#125; &#125;) // =&gt; &#123;&quot;name&quot;: &#123; &quot;first&quot;: &quot;Charles&quot;, &quot;last&quot;: &quot;Lopez&quot;, &quot;full&quot;: &quot;Charles Lopez&quot; &#125;&#125; 综合示例Mock.mock(&#123; &quot;list|10&quot;: [ &#123; &quot;id&quot;: &quot;@GUID&quot;, &quot;first&quot;: &quot;@CFIRST&quot;, &quot;last&quot;: &quot;@CLAST&quot;, &quot;name&quot;: &quot;@first@last&quot;, &quot;age|10-60&quot;: 1, &quot;gender&quot;: &quot;@pick([1,2])&quot;, &quot;say&quot;: function()&#123; return &quot;my name is &quot; + this.name; &#125; &#125; ]&#125;) Mock.Random Mock.Random 是一个工具类，用于生成各种随机数据，调用方式有2种： // 1. 直接调用 Matn.random 方法var Random = Mock.Random;Random.boolean()Random.boolean(1, 9, true)// 2. 数据占位符调用Mock.mock(&apos;@boolean&apos;)Mock.mock(&apos;@boolean()&apos;)Mock.mock(&apos;@boolean(1, 9, true)&apos;) 自定义占位符// 自定义占位符Mock.Random.extend(&#123; constellations: [ &apos;白羊座&apos;, &apos;金牛座&apos;, &apos;双子座&apos;, &apos;巨蟹座&apos;, &apos;狮子座&apos;, &apos;处女座&apos;, &apos;天秤座&apos;, &apos;天蝎座&apos;, &apos;射手座&apos;, &apos;摩羯座&apos;, &apos;水瓶座&apos;, &apos;双鱼座&apos; ], constellation: function(date)&#123; return this.pick(this.constellations) &#125;&#125;)Random.constellation()// =&gt; &quot;水瓶座&quot;Mock.mock(&apos;@CONSTELLATION&apos;)// =&gt; &quot;天蝎座&quot;Mock.mock(&#123; constellation: &apos;@CONSTELLATION&apos;&#125;)// =&gt; &#123; constellation: &quot;射手座&quot; &#125; Basicsboolean：布尔值 Random.boolean(min?, max?, current?) 参数说明参见 数据模版定义-Boolean natural：自然数（大于等于 0 的整数） Random.natural( min?, max? ) 参数 min：可选。指示随机自然数的最小值。默认值为 0。 参数 max：可选。指示随机自然数的最小值。默认值为 9007199254740992。 integer：整数（包含负数） Random.integer( min?, max? ) 参数 min：可选。指示随机整数的最小值。默认值为 -9007199254740992。 参数 max：可选。指示随机整数的最大值。默认值为 9007199254740992。 float：浮点数 Random.float( min?, max?, dmin?, dmax? ) 参数 min：可选。整数部分的最小值。默认值为 -9007199254740992。 参数 max：可选。整数部分的最大值。默认值为 9007199254740992。 参数 dmin：可选。小数部分 位数 的最小值。默认值为 0。 参数 dmin：可选。小数部分 位数 的最大值。默认值为 17。 character：单个字符 Random.character( pool? ) 参数 pool：可选。字符串。表示字符池，将从中选择一个字符返回。 如果传入 &#39;lower&#39; 或 &#39;upper&#39;、&#39;number&#39;、&#39;symbol&#39;，表示从内置的字符池从选取。 如果未传入该参数，则从 &#39;lower&#39; + &#39;upper&#39; + &#39;number&#39; + &#39;symbol&#39; 中随机选取一个字符返回。 &gt; 内置字符池：&gt; lower: &quot;abcdefghijklmnopqrstuvwxyz&quot;,&gt; upper: &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,&gt; number: &quot;0123456789&quot;,&gt; symbol: &quot;!@#$%^&amp;*()[]&quot;&gt; string：字符串 Random.string( pool?, min?, max? ) 参数 pool：可选。字符串。释义同上字符。 参数 min：可选。随机字符串的最小长度。默认值为 3。 参数 max：可选。随机字符串的最大长度。默认值为 7。 range：整型数组 Random.range(stop) 一个参数：表示数组中整数的结束值（不包含在返回值中） Random.range(start?, stop, step?) 参数 start：可选。数组中整数的起始值，默认值为 0。 参数 stop：必选。数组中整数的结束值（不包含在返回值中）。 参数 step：可选。数组中整数之间的步长，默认值为 1。 // 一个参数表示结束值Random.range(10)// =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]// 多参数Random.range(3, 7)// =&gt; [3, 4, 5, 6]Random.range(1, 10, 2)// =&gt; [1, 3, 5, 7, 9]Random.range(1, 10, 3)// =&gt; [1, 4, 7] Date 参数 format：可选。格式化生成的日期字符串。默认值为 yyyy-MM-dd。可选值参照 date-format date：日期字符串 Random.date( format? ) time：时间字符串 Random.time(format?) datetime：随机的日期和时间字符串 Random.datetime( format? ) now：当前的日期和时间字符串 Random.now( unit?, format? ) 参数 unit：可选。表示时间单元，用于对当前日期和时间进行格式化。 ​ 可选值有：year、month、week、day、hour、minute、second、week，默认不会格式化。 参数 format：可选。指示生成的日期和时间字符串的格式。默认值为 yyyy-MM-dd HH:mm:ss。 Random.now()// =&gt; &quot;2018-11-09 10:28:53&quot;// Ranndom.now( unit ) Random.now(&apos;year&apos;) // =&gt; &quot;2018-01-01 00:00:00&quot; Random.now(&apos;month&apos;) // =&gt; &quot;2018-11-01 00:00:00&quot; Random.now(&apos;week&apos;) // =&gt; &quot;2018-11-04 00:00:00&quot; Random.now(&apos;day&apos;) // =&gt; &quot;2018-11-09 00:00:00&quot; Random.now(&apos;hour&apos;) // =&gt; &quot;2018-11-09 20:00:00&quot; Random.now(&apos;minute&apos;) // =&gt; &quot;2018-11-09 20:08:00&quot; Random.now(&apos;second&apos;) // =&gt; &quot;2018-11-09 20:08:38&quot;// Ranndom.now( unit, format ) Random.now(&apos;day&apos;, &apos;yyyy-MM-dd HH:mm:ss SS&apos;) // =&gt; &quot;2018-11-09 00:00:00 000&quot; Imageimage：图片URL Random.image( size?, background?, foreground?, format?, text? ) 参数 size：可选。指示图片的宽高，格式为 &#39;宽x高&#39;。默认从下面的数组中随机读取一个 [ &apos;300x250&apos;, &apos;250x250&apos;, &apos;240x400&apos;, &apos;336x280&apos;, &apos;180x150&apos;, &apos;720x300&apos;, &apos;468x60&apos;, &apos;234x60&apos;, &apos;88x31&apos;, &apos;120x90&apos;, &apos;120x60&apos;, &apos;120x240&apos;, &apos;125x125&apos;, &apos;728x90&apos;, &apos;160x600&apos;, &apos;120x600&apos;, &apos;300x600&apos; ] 参数 background：可选。图片的背景色（16进制颜色）。默认值为 ‘#000000’。使用英文单词(red等)表示颜色无效 参数 foreground：可选。图片的前景色（文件）。默认值为 ‘#FFFFFF’。使用英文单词(red等)表示颜色无效 参数 format：可选。指示图片的格式。默认值为 ‘png’，可选值包括：’png’、’gif’、’jpg’。 参数 text：可选。指示图片上的文字(中文无效)。默认为参数 size（尺寸大小 eg：200x100）。 Random.image(&apos;200x100&apos;, &apos;#FF0000&apos;, &apos;#FFF&apos;, &apos;png&apos;, &apos;text&apos;)// =&gt;&quot;https://dummyimage.com/200x100/FF0000/FFF.png&amp;text=text&quot; dataImage：base64图片 Random.dataImage( size?, text? ) 图片的背景色是随机的，取值范围参考自 http://brandcolors.net/。 Colorcolor：’#RRGGBB’ Random.color() 返回16进制颜色（’#RRGGBB’） hex : ‘#RRGGBB’ Random.hex() 返回16进制颜色（’#RRGGBB’） rgb：’rgb(r, g, b)’ Random.rgb() rgba：’rgb(r, g, b, a)’ Random.rgba() hsl：’hsl(h, s, l)’ Random.hsl() Random.color()// =&gt; &quot;#f279c3&quot;Random.hex()// =&gt; &quot;#7988f2&quot;Random.rgb()// =&gt; &quot;rgb(242, 184, 121)&quot;Random.rgba()// =&gt; &quot;rgba(242, 121, 164, 0.58)&quot;Random.hsl()// =&gt; &quot;hsl(286, 82, 71)&quot; Textparagraph：英文段落（多条句子） Random.paragraph( len ) 参数 len：可选。指示文本中句子的个数。默认值为 3 到 7 之间的随机数。 Random.paragraph( min?, max? ) 参数 min：可选。指示文本中句子的最小个数。默认值为 3。 参数 max：可选。指示文本中句子的最大个数。默认值为 7。 sentence：一个英文句子 随机生成一个句子，第一个的单词的首字母大写。 Random.sentence( len ) 参数 len：可选。指示句子中单词的个数。默认值为 12 到 18 之间的随机数。 Random.sentence( min?, max? ) 参数 min：可选。指示句子中单词的最小个数。默认值为 12。 参数 max：可选。指示句子中单词的最大个数。默认值为 18。 word：英文单词 Random.word( len ) 参数 len：可选。指示单词中字符的个数。默认值为 3 到 10 之间的随机数。 Random.word( min?, max? ) 参数 min：可选。指示单词中字符的最小个数。默认值为 3。 参数 max：可选。指示单词中字符的最大个数。默认值为 10。 Random.word()// =&gt; &quot;fzljqtu&quot; title：标题 随机生成一句标题，其中每个单词的首字母大写。 Random.title( len ) 参数 len：可选。指示标题中单词的个数。默认值为 3 到 7 之间的随机数。 Random.title( min?, max? ) 参数 min：可选。指示标题中单词的最小个数。默认值为 3。 参数 max：可选。指示标题中单词的最大个数。默认值为 7。 Random.title()// =&gt; &quot;Odd Krdote Tidnsovvr Gcljiwzk Gtbckxopbg Vhfr&quot; cparagraph：中文段落 参数同 paragraph Random.cparagraph( len ) Random.cparagraph( min?, max? ) Random.cparagraph()// =&gt; &quot;科叫强上全六党争很温素通。增精老新节劳人要格原山设总。可京条眼作少空么属气众原并是结型。社马高率主约样明只事过且往除。&quot; csentence：中文句子 参数同 sentence Random.cparagraph( len ) Random.cparagraph( min?, max? ) Random.csentence()// =&gt; &quot;气想指选价领金高每提实式转。&quot; cword：汉字 Random.cword(pool？） Random.cword(pool？, length？） Random.cword( pool?, min?, max? ) Random.cword(length？） Random.cword(min, max） 参数 pool：可选。字符串。表示字符池，将从中选择汉字返回(可重复选择)。 参数 length：可选。指示随机汉字的长度，默认值为 1。 参数 min：可选。指示随机汉字的最小长度。 参数 max：可选。指示随机汉字的最大长度。 // Random.cword()Random.cword()// =&gt; &quot;况&quot;// Random.cword( pool )Random.cword(&apos;零一二三四五六七八九十&apos;)// =&gt; &quot;十&quot;// Random.cword( length )Random.cword(3)// =&gt; &quot;万为此&quot;// Random.cword( pool, length )Random.cword(&apos;零一二三四五六七八九十&apos;, 3)// =&gt; &quot;五三六&quot;// Random.cword( min, max )Random.cword(3, 5)// =&gt; &quot;眼克好金少&quot;// Random.cword( pool, min, max )Random.cword(&apos;零一二三四五六七八九十&apos;, 5, 7)// =&gt; &quot;二五五八三六&quot; ctitle：中文标题 Random.ctitle(length？） Random.ctitle(min, max） 参数 length：可选。指示随机标题的长度。 参数 min：可选。指示随机标题的最小长度，默认值为3。 参数 max：可选。指示随机标题的最大长度，默认值为7。 Random.ctitle(3, 5)// =&gt; &quot;路属改往&quot; Namefirst：英文名 Random.first() 随机生成一个常见的英文名。 last：英文姓 Random.last() 随机生成一个常见的英文姓。 name：英文姓名 Random.name( middle? ) 随机生成一个常见的英文姓名。 参数 middle：可选。布尔值。指示是否生成中间名。 Random.name()// =&gt; &quot;Larry Wilson&quot;Random.name(true)// =&gt; &quot;Helen Carol Martinez&quot; cfirst：中文姓 Random.cfirst() 随机生成一个常见的中文姓氏。 clast：中文名 Random.clast() 随机生成一个常见的中文名。 cname：中文姓名 Random.cname() Random.cname()// =&gt; &quot;薛静&quot; Weburl：url地址 Random.url() Random.url()// =&gt; &quot;gopher://qmug.sh/uprwjbph&quot; domain：域名 Random.domain() Random.domain()// =&gt; &quot;ynadsh.tj&quot; protocal：协议 Random.protocol() Random.protocol()// =&gt; &quot;http&quot; tld：顶级域名 Random.tld() Random.tld()// =&gt; &quot;nz&quot; ip Random.ip() Random.ip()// =&gt; &quot;97.167.99.146&quot; email：邮箱 Random.email() Random.email()// =&gt; &quot;t.tfiktg@krrsjpfs.mil&quot; Addressregion：大区 Random.region() 随机生成一个（中国）大区。 Random.area()// =&gt; &quot;华北&quot; province：省（或直辖市、自治区、特别行政区） Random.province() Random.city()// =&gt; &quot;安徽省&quot; city：城市 Random.city( prefix? ) 参数 prefix：可选。布尔值。指示是否生成所属的省。默认值为 false。 Random.city()// =&gt; &quot;海东市&quot;Random.city(true)// =&gt; &quot;吉林省 吉林市&quot; county：县（区） Random.county( prefix? ) 参数 prefix：可选。布尔值。指示是否生成所属的省、市。默认值为 false。 Random.county()// =&gt; &quot;永胜县&quot;Random.county(true)// =&gt; &quot;河南省 安阳市 龙安区&quot; zip：邮政编码 Random.zip() 随机生成一个邮政编码（六位数字） Random.zip()// =&gt; &quot;139862&quot; Helper：工具类capitalize：首字母大写 Random.capitalize( word ) Random.capitalize( &apos;hello&apos; )// =&gt; &quot;Hello&quot; upper：大写转换 Random.upper( str ) Random.upper(&apos;hello WORld&apos;)// =&gt; &quot;HELLO WORLD&quot; lower：小写转换 Random.lower( str ) Random.lower(&apos;HELLO WorLD&apos;)// =&gt; &quot;hello world&quot; pick：元素选取 Random.pick( arr ) 从数组中随机选取一个元素，并返回 Random.pick([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;])// =&gt; &quot;o&quot; shuffle：打乱 Random.shuffle( arr ) 打乱数组中元素的顺序，并返回。 Random.shuffle([&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;])// =&gt; [&quot;i&quot;, &quot;u&quot;, &quot;a&quot;, &quot;o&quot;, &quot;e&quot;] Miscellaneous：杂项guid：随机标识符 Random.guid() 随机生成一个 GUID。Random.guid() 的实现参考了 UUID 规范。 Random.guid()// =&gt; &quot;8Dc8DA10-3FDe-FFc8-3AD6-703bdeFff0D8&quot; id：18 位身份证。 Random.id() // 随机生成一个 18 位身份证。Random.id()// =&gt; &quot;620000201010107263&quot; increment：自增整数 Random.increment( step? ) 参数 step：可选。整数自增的步长。默认值为 1。起始值为0。 生成一个 全局 的自增整数。 全局变量！！！ // 仔细观察每次调用 Random.increment 后的返回值Random.increment()// =&gt; 1 （0+1）Random.increment()// =&gt; 2 （1+1）Random.increment(100)// =&gt; 102 （2+100）Random.increment()// =&gt; 103 (102+1) Mock.mock() Mock.js 通过覆盖和模拟原生 XMLHttpRequest 的行为来拦截 Ajax 请求 当前版本只能拦截Ajax请求，故对此方法不做过多记录，有兴趣的同学可以查看 官方文档) Mock.mock( rurl?, rtype?, template|function( options ) ) Mock.mock( template ) Mock.mock( rurl, template ) Mock.mock( rurl, function(options) ) Mock.mock( rurl, rtype, template ) Mock.mock( rurl, rtype, function(options) ) 参数 rurl：可选。表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。 ​ 例如 /\/domain\/list\.json/、&#39;/domian/list.json&#39;。 参数 rtype：可选。表示需要拦截的 Ajax 请求类型。 ​ 例如 GET、POST、PUT、DELETE 等。 参数 template：可选。表示数据模板，可以是对象或字符串。 ​ 例如 { &#39;data|1-10&#39;:[{}] }、&#39;@EMAIL&#39;。 参数 function(options)：可选。表示用于生成响应数据的函数。 参数 options：指向本次请求的 Ajax 选项集。 ​ 含有 url、type 和 body 三个属性，参见 XMLHttpRequest 规范。 // Mock.mock( rurl, rtype, template )Mock.mock(/\.json/, &apos;post&apos;, &#123; &apos;list|1-10&apos;: [&#123; &apos;id|+1&apos;: 1, &apos;email&apos;: &apos;@EMAIL&apos; &#125;]&#125;)$.ajax(&#123; url: &apos;list.json&apos;, type: &apos;post&apos;, dataType: &apos;json&apos;&#125;).done(function (data, status, jqXHR) &#123; console.log(data)&#125;) Mock.setup(settings ) 参数settings：必选。指示配置项对象。配置拦截 Ajax 请求时的行为。 Mock.setup( settings ) 仅用于配置 Ajax 请求，同上，有兴趣的同学可以查看 官方文档) settings：配置项timeout 可选。指定被拦截的 Ajax 请求的响应时间，单位是毫秒。 值可以是正整数，例如 400，表示 400 毫秒 后才会返回响应内容 也可以 ‘200-600’，表示响应时间介于 200 和 600 毫秒之间。默认值是&#39;10-100&#39;。 Mock.setup(&#123; timeout: 400&#125;)Mock.setup(&#123; timeout: &apos;200-600&apos;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日历插件]]></title>
    <url>%2F2017%2F10%2F30%2F2017-10-30-datepicker%2F</url>
    <content type="text"><![CDATA[js原生日历插件，功能尚未完善。。。 目前只实现了最基础的日历数据获取 《 &lt; 2017年 10月 &gt; 》 一 二 三 四 五 六 日 29 30 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 1 2 3 4 5 6 7 8 9 10 今天 var style = document.createElement('link'); style.rel='stylesheet'; // 动态加载样式 if(navigator.userAgent.match(/(iPhone|iPod|Android|ios|webOS|iPad|BlackBerry|Windows Phone|Symbian)/i)){ style.href = '/assets/css/datepicker-mobile.css'; }else{ style.href = '/assets/css/datepicker.css'; } document.getElementsByTagName('head')[0].appendChild(style); var formatSign = '-'; var oTable = $$('.my-date-table')[0]; var oInput = $$('.my-date-input')[0]; var oYearPre = $$('.my-date-select-year-pre-btn')[0]; var oYearNext = $$('.my-date-select-year-next-btn')[0]; var oMonthPre = $$('.my-date-select-month-pre-btn')[0]; var oMonthNext = $$('.my-date-select-month-next-btn')[0]; var oYear = $$('.my-date-year-select')[0]; var oMonth = $$('.my-date-month-select')[0]; var oTds = $$('.date-cell'); var currDate = {}; init(); /* 功能： 1. 日期格式化 2. 选日期 3. 选时间 4. 选范围 5. 是否显示footer */ // 给年份添加点击事件 oYear.addEventListener('click',function(){ console.log('selectYear') // 新建一个div覆盖在原table上 }) // 给月份添加点击事件 oMonth.addEventListener('click',function(){ console.log('selectMonth') // 新建一个div覆盖在原table上 }) // 点击上一年 oYearPre.addEventListener('click',function(){ var year = parseInt(oYear.innerHTML)-1; var month = parseInt(oMonth.innerHTML); oYear.innerHTML = year+'年'; // 更新日历表格数据 renderTable(getDateData(year,month)); }) // 点击下一年 oYearNext.addEventListener('click',function(){ var year = parseInt(oYear.innerHTML)+1; var month = parseInt(oMonth.innerHTML); oYear.innerHTML = year+'年'; // 更新日历表格数据 renderTable(getDateData(year,month)); }) // 点击上一月 oMonthPre.addEventListener('click',function(){ var year = parseInt(oYear.innerHTML); var month = parseInt(oMonth.innerHTML); // 当月份为1时，年份-1 if(month===1){ year--; oYear.innerHTML = year+'年'; month=13 } month--; oMonth.innerHTML = month+'月'; // 更新日历表格数据 renderTable(getDateData(year,month)); }) // 点击下一月 oMonthNext.addEventListener('click',function(){ var month = parseInt(oMonth.innerHTML); var year = parseInt(oYear.innerHTML); // 当月份为12时，年份+1 if(month===12){ year++; oYear.innerHTML = year+'年'; month=0 } month++; oMonth.innerHTML = month+'月'; // 更新日历表格数据 renderTable(getDateData(year,month)); }) // 给日期添加点击事件 oTds.map(function(v,k){ v.addEventListener('click',function(e){ var year = this.getAttribute('year')*1; var month = this.getAttribute('month')*1; var date = this.getAttribute('date')*1; // 赋值 if(currDate.year===year&&currDate.month===month&&currDate.date===date){ return void 666 } oInput.value = year+formatSign+getNum(month)+formatSign+getNum(date); oYear.innerHTML = year+'年'; oMonth.innerHTML = month+'月'; // 2. 不是这个月的重新渲染数据 var selectDate = { year:year, month:month, date:date, } if(month!==currDate.month){ renderTable(getDateData(year,month),selectDate); }else{ var parent = $$('.my-date-table')[0]; var preSelect = $$('.my-date-select',parent); if(preSelect.length){ removeClass(preSelect[0],'my-date-select'); } addClass(this,'my-date-select'); } currDate = selectDate; }) }) // 初始化日历组件 function init(config){ renderTable(); currDate = getCurrDate(); oInput.value = currDate.year+formatSign+getNum(currDate.month)+formatSign+getNum(currDate.date); } // 获取日历表格数据 function getDateData(year,month){ if(!year||!month){ var today = new Date(); year = today.getFullYear(); month = today.getMonth()+1; } // 本月第一天 var firstDay = new Date(year,month-1,1); // 本月第一天的星期 var firstDateOfCurr = firstDay.getDay(); if(firstDateOfCurr===0){firstDateOfCurr=7} // 要显示的上个月的日期的数量 var countOfPreMonth = firstDateOfCurr - 1; // 本月最后一天 var lastDay = new Date(year,month,0); // 本月最后一天的日期 var lastDateOfCurr = lastDay.getDate(); // 上个月最后一天 var lastDayOfPreMonth = new Date(year,month-1,0); // 上个月最后一天的日期 var lastDateOfPreMonth = lastDayOfPreMonth.getDate(); var tableDate = []; // 获取table的数据 for(var i=0;i9?parseInt(num):('0'+parseInt(num)) } // 是否有指定class function hasClass(ele,cls){ var eleCls = ele.className||''; var clsArr = eleCls.split(' '); if(clsArr.length){ return clsArr.indexOf(cls) !== -1; }else{ return false } } // 添加指定class function addClass(ele,cls){ if(!hasClass(ele,cls)){ ele.className = ele.className+" "+cls }else{ console.log(ele+'已有类名'+cls) } } // 移除指定class function removeClass(ele,cls){ if(hasClass(ele,cls)){ var clsArr = ele.className.split(' '); var index = clsArr.indexOf(cls); clsArr.splice(index,1); ele.className = clsArr.join(' '); }else{ console.log(ele+'没有类名'+cls) } } // 查找元素 function $$(str,parent){ parent = parent?parent:document if(!str){ return void 666; } if(/^#/.test(str)){ return parent.getElementById(str.substring(1,str.length)); }else if(/^\./.test(str)){ return Array.prototype.slice.apply(parent.getElementsByClassName(str.substring(1,str.length))); }else{ return Array.prototype.slice.apply(parent.getElementsByTagName(str)); } }]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片墙]]></title>
    <url>%2F2017%2F10%2F23%2F2017-10-23-picture-wall%2F</url>
    <content type="text"><![CDATA[图片加载较慢，需要耐心等待。。。 /** * [createWall description] * @param {[type]} id [容器id] * @param {[type]} imgUrls [图片源] * @param {[type]} rows [行] * @param {[type]} cols [列] * @param {[type]} gap [图片间隙] * @param {[type]} type [容器的宽度] * @param {[type]} sWight [容器的高度] * @param {[type]} sHeight [容器的高度] * @param {[type]} imgHeight [图片的高度] * @param {[type]} imgHeight [图片的高度] * */ var ImgWall = (function(){ // 配置项 var _option = { id:'', imgUrls:[], rows:1, cols:1, gap:5, sWidth:100, sHeight:100 } var _pictureWall = { init: function(config){ if(!config.id){ return alert('请输入id') } for(var key in config){ _option[key] = config[key] } this.createWall(_option) }, // 创建照片墙 createWall: function(config){ var id = config.id; var imgUrls = config.imgUrls; var rows = config.rows; var cols = config.cols; var gap = config.gap; var sWidth = config.sWidth; var sHeight = config.sHeight; var _this = this; var oWall = document.getElementById(config.id); oWall.style.width = sWidth + 'px'; oWall.style.height = sHeight + 'px'; oWall.style.boxSizing = "border-box"; oWall.style.overflow = "hidden"; oWall.style['-webkit-transition'] = "all 1s linear"; oWall.style['-moz-transition'] = "all 1s linear"; oWall.style['-ms-transition'] = "all 1s linear"; oWall.style['-o-transition'] = "all 1s linear"; oWall.style['transition'] = "all 1s linear"; var imgWidth = (sWidth-cols*gap*2)/cols; var imgHeight = (sHeight-rows*gap*2)/rows; imgUrls.map(function(v,k) { var oDiv = document.createElement('div') oDiv.setAttribute('data-idx',k); oDiv.style.float = 'left'; oDiv.style.backgroundImage = 'url('+ v +')'; oDiv.style.backgroundSize = '100% 100%'; oDiv.style.width = imgWidth + 'px'; oDiv.style.height = imgHeight + 'px'; oDiv.style.margin = gap + 'px'; oDiv.style.cursor = "pointer"; oDiv.style['-webkit-transition'] = "all 1s linear"; oDiv.style['-moz-transition'] = "all 1s linear"; oDiv.style['-ms-transition'] = "all 1s linear"; oDiv.style['-o-transition'] = "all 1s linear"; oDiv.style['transition'] = "all 1s linear"; oDiv.addEventListener('click',function(){ _this.switchShow(id,k) }) oWall.appendChild(oDiv) }) }, // 切换显示方式 switchShow: function(id,idx){ var oWall = document.getElementById(id); var children = oWall.getElementsByTagName('div'); // 将dom变为真正的数组 children = Array.prototype.slice.call(children); var switchFlag = oWall.getAttribute('data-switch') === 'off'; // off: 照片墙，on: 全屏 oWall.setAttribute('data-switch',switchFlag?'on':'off'); if(switchFlag){ this.bigModel(children,idx) }else{ this.wallModel(children,idx) } }, // 1图模式 bigModel: function(children,idx){ // 根据_option设置背景图位置 var oWall = document.getElementById(_option.id); oWall.style.padding = _option.gap*_option.rows+"px"+" "+_option.gap*_option.cols+"px"; var width = children[0].offsetWidth; var height = children[0].offsetHeight; children.map(function(v,k) { var positionX = width*(-k%_option.cols)+"px"; var positionY = -height*Math.floor(k/_option.cols)+"px"; v.style.backgroundImage = "url("+_option.imgUrls[idx]+")"; v.style.backgroundPosition = positionX+" "+positionY; v.style.backgroundSize = (_option.sWidth-_option.gap*_option.cols*2)+"px "+(_option.sHeight-_option.gap*_option.rows*2)+"px"; v.style.margin = 0; }) }, // 照片墙模式 wallModel: function(children,idx){ var oWall = document.getElementById(_option.id); oWall.style.padding = "0"; children.map(function(v,k) { v.style.backgroundImage = "url("+_option.imgUrls[k]+")" v.style.backgroundPosition = "0 0"; v.style.backgroundSize = "100% 100%"; v.style.margin = _option.gap + "px"; }) } } return _pictureWall }()) var imgUrls = [ '/assets/images/1.jpg', '/assets/images/2.jpg', '/assets/images/3.jpg', '/assets/images/4.jpg', '/assets/images/5.jpg', '/assets/images/6.jpg', '/assets/images/7.jpg', '/assets/images/8.jpg', '/assets/images/9.jpg', '/assets/images/10.jpg', '/assets/images/11.jpg', '/assets/images/12.jpg', ] // 将url转化为base64 function convertImgToBase64(url, callback){ var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); var img = new Image(); img.crossOrigin = 'Anonymous'; img.onload = function(){ canvas.height = img.height; canvas.width = img.width; ctx.drawImage(img,0,0); var dataURL = canvas.toDataURL('image/png'); callback.call(this, dataURL); canvas = null; }; img.src = url; } /*imgUrls.map(v => { // 转换base64 convertImgToBase64(v,function(base64Img) { v = base64Img console.log('base64',v) }) })*/ /* 配置项： 1. 尺寸配置size: 1. 比例显示：默认16:9 2. 固定宽高：单位px 2. 显示样式type: 1. 放大缩小： 2. 其他方式 */ var config = { id: 'photo-wall', imgUrls: imgUrls, rows: 3, cols: 4, gap: 10, sWidth: 640, // (imgWidth+gap*2)*cols sHeight: 360,// (imgHeight+gap*2)*rows } // 移动端监测 if(navigator.userAgent.match(/(iPhone|iPod|Android|ios|webOS|iPad|BlackBerry|Windows Phone|Symbian)/i)){ // alert(navigator.userAgent) var width = window.screen.availWidth*0.8 var height = ((width/config.cols-config.gap*2)*9/16+config.gap*2)*config.rows config.sWidth = width config.sHeight = height } ImgWall.init(config)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>demo</tag>
      </tags>
  </entry>
</search>
